<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/*
			 正则新增特性
			 构造函数的变化  正则方法的扩展  u修饰符  y修饰符   s修饰符*/
			{
				let regex = new RegExp('xyz','i');
				let regex2 = new RegExp(/xyz/i);
				console.log(regex.test('xyz123'),regex2.test('xyz123'));
				
				
				let regex3 = new RegExp(/xyz/ig,'i');
				console.log(regex3.flags);
			}
			
			
			
			//g和y都是全局匹配  不同的是 
			//g是从上次匹配的位置继续寻找  直到找到可以匹配的位置
			//y是必须紧跟的下一个字符
			
			{
				let s = 'bbb_bb_b';
				let a1 = /b+/g;
				let a2 = /b+/y;
				
				console.log('one',a1.exec(s),a2.exec(s));
				console.log('two',a1.exec(s),a2.exec(s));
				
				
				//sticky 判断是否开启y修饰符
				console.log(a1.sticky,a2.sticky);
			}
			
			/*u修饰符*/
			/*没加u会当成两个字符*/
			/*加u会当做10字符*/
			/*大括号会当做一个整体的字符  必须加u*/
			/*如果字符串中有的字符串时大于两个字节，一定要加u才能够正确识别*/
			{
				console.log('u-1',/^\uD83D/.test('\uD83D\uDC2A'));
				console.log('u-1',/^\uD83D/u.test('\uD83D\uDC2A'));
				
				console.log(/\u{61}/.test('a'));
				console.log(/\u{61}/u.test('a'));
				
				console.log('\u{20BB7}');
				let s = '𠮷';
				console.log('u',/^.$/.test(s));
				console.log('u',/^.$/u.test(s));
				
			    console.log('test',/𠮷{2}/.test('𠮷𠮷'));
			    console.log('test-2',/𠮷{2}/u.test('𠮷𠮷'));
			    
			 	
				
			}
		</script>
	</body>
</html>
