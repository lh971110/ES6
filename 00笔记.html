<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		一：let和const
		    1.let不存在声明变量提前
		    2.在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，
		                称为“暂时性死区”（temporal dead zone，简称 TDZ）。
		
		    3.const表示定义一个常量  不能更改常量的值  但是可以指向一个引用类型的值
		                对这个引用类型的值的操作方法是允许的  但是不能允许指向别的值
		               如果要冻结对象  用Object.freeze(); 但是只能冻结一层 
		    4.let和const定义声明的方法都不是定义在全局 
		               
		二.解构赋值
		    1.数组解构用[],对象解构用{}
		    2.区分数组还是解构？
		               看他在是在赋值还是在取值，等号左边的都是解构，等号右边的都是数组或者对象
		    3....必须出现在最后一个  叫rest运算符
		    4.函数的参数也可以解构  将一个数组传入了函数  函数自动帮我拆开数组 和apply作用类似
		    5.形参列表中还可以有对象的自动解构语法
		    6.对象还有一个k:v的解构模式  冒号右边的变量才是真正的被赋值
		    
		三.字符串的增强
		    1.原来我们只能用A.indexOf(B)来判断A字符串是否含有B字符串
		               现在有了includes startWith EndWith
		    2.repeat(n)  表示重复字符串n次
		    3.模板字符串  新增加的运算符  可以有轻微运算  不可以有复杂逻辑  ``中的东西可以换行
		    
		四.数组的增强
		    1.Array.from()可以将类数组对象变为真的数组
		    2.Array.of()将一组值转换为数组
		    3.find(),里面要放回调函数  有三个参数  （项 编号 数组本身 ） 机理是js测试每一个项目
		               返回第一个为true的对象  没有项返回undefined
		    4.findIndex()返回第一个为true的对象的下标  没有项返回-1
		    5.增加了一种遍历数组的方法 for...of...  通常配合arr.entries()和arr.keys()来使用
		                遍历的时候数组用of 对象用in
		    6.includes()返回一个布尔值  判断数组中是否存在某个项
		    
		五.对象的增强
		    1.如果kv一致，此时可以省略v
		    2.属性名表达式  []可以出现在{}内  表示变量key
		    3.Object.assign(方法可用于对象的合并，第一个参数是目标对象，后面的是源对象 
		    4.Object.keys(obj5)方法得到obj5对象的所有键
		    5.扩展运算符 
		    6.拓展运算符
		六.Promise对象
		    1.可以调用then方法 
		    2.catch 方法  表示捕获异常 
		    3.Promise.all(数组)  表示数组中的Promise实例执行完毕之后做的事情，也可以调用then()
		      then方法接受实参xxx，表示数组中所有的promise对象resolve的实参组成的数组
		    4.Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。
		        Promise.resolve('foo')
                 // 等价于
                new Promise(resolve => resolve('foo'))
                     七.类的定义
            1.class 底层还是prototype那套东西，也就是说构造还是存在，只不过写在class里面的constructor里面了
              window还有一个People函数属性，People函数还是有prototype，我们写的属性方法都是在
              prototype身上
            2.class继承
              ES6并没有深化'继承'	
                     八.箭头函数
            1.如果函数体中只有一条语句，此时不需要写大括号，不需要写return
            2.注意：
                1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
                2.不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
                3.不可以使用arguments对象，该函数在函数体内不存在，如果要用，可以用Rest参数代替
            3.function可以call/apply  箭头函数不可以call/apply;
            4.箭头不可以使用bind()  function 可以使用bind() 但是其显示固定函数上下文
                                     不管怎样调用函数  函数的上下文不会改变
	</body>
</html>
